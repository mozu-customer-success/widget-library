'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var path = _interopDefault(require('path'));
var fs = _interopDefault(require('fs-extra'));
var chalk = _interopDefault(require('chalk'));
var isObject = _interopDefault(require('is-plain-object'));

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};

  var target = _objectWithoutPropertiesLoose(source, excluded);

  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

function processArrayOfTargets(targets, outputFolder) {
  return targets.map(target => ({
    from: target,
    to: path.join(outputFolder, path.basename(target))
  }));
}

function processObjectOfTargets(targets) {
  return Object.entries(targets).reduce((processedTargets, [from, to]) => Array.isArray(to) ? [...processedTargets, ...to.map(target => ({
    from,
    to: target
  }))] : [...processedTargets, {
    from,
    to
  }], []);
}

function copy(options = {}) {
  const {
    outputFolder,
    targets = [],
    verbose = false,
    warnOnNonExist = false
  } = options,
        rest = _objectWithoutProperties(options, ["outputFolder", "targets", "verbose", "warnOnNonExist"]);

  return {
    name: 'copy',

    async generateBundle(outputOptions) {
      let processedTargets = [];

      if (Array.isArray(targets) && targets.length) {
        const destFolder = outputFolder || outputOptions.dir || path.dirname(outputOptions.file);
        processedTargets = processArrayOfTargets(targets, destFolder);
      }

      if (isObject(targets) && Object.entries(targets).length) {
        processedTargets = processObjectOfTargets(targets);
      }

      if (processedTargets.length) {
        if (verbose) {
          console.log('Copied files and folders:');
        }

        await Promise.all(processedTargets.map(async ({
          from,
          to
        }) => {
          try {
            await fs.copy(from, to, rest);

            if (verbose) {
              console.log(chalk.green(`${from} -> ${to}`));
            }
          } catch (e) {
            if (e.code === 'ENOENT') {
              if (verbose) {
                console.log(chalk.red(`${from} -> ${to} (no such file or folder: ${e.path})`));
              }

              if (warnOnNonExist) {
                this.warn(e);
              }
            } else {
              this.error(e);
            }
          }
        }));
      }
    }

  };
}

module.exports = copy;
